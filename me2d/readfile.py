#! /usr/bin/env python3

"""
read E- or E-,J-resolved density of states and microscopic rate constants
"""

import sys, os, time
import numpy as np


def read1d(fn, maxE=None):
    """ read E-resolved rho and k[ch] from rrkmE file (generated by rrkmE()) """
    fp = open(fn)
    rhol = []
    kl = None
    nchan = None
    E0, dE, Eprev = None, None, None
    for l in fp:
        if l.strip() == "": continue
        if l.strip().startswith("#"):
            l1 = l[1:].strip()
            if l1.startswith("nchan = "): nchan = int(l1.split()[2])
            continue
        if l.strip().startswith("E"): continue
        ls = l.split()
        E = int(ls[0])
        if (maxE is not None) and (E > maxE): continue
        if E0 is None: E0 = E
        elif dE is None: dE = E - E0
        elif (Eprev is not None) and (dE != E - Eprev):
            raise ValueError("non-uniform dE")
        Eprev = E
        
        if nchan is None: nchan = len(ls) - 2
        if kl is None: kl = [[] for ich in range(nchan)]
        rhol.append(float(ls[1]))
        for ich in range(nchan): kl[ich].append(float(ls[ich+2]))
        
    rho = np.array(rhol)
    kl = [np.array(kl[ich]) for ich in range(nchan)]
    return dE, rho, kl


def read2d(fn, dJ, maxE=None, maxJ=None):
    """ read E,J-resolved rho and k[ch] from rrkmEJ file (generated by rrkmEJ()) """
    fp = open(fn)
    nsiz = 0
    Jl = []
    offsetl = []
    rhol = []
    kll = None
    nchan = None
    B2D = None
    E0, dE = None, None
    while True:
        J, offset = None, None
        for l in fp:
            if l.strip().startswith("#"):
                l1 = l[1:].strip()
                if nchan is None and l1.startswith("nchan = "):
                    nchan = int(l1.split()[2])
                if l1.startswith("B2D ="):
                    B2D = float(l1.split()[2])
                if l1.startswith("J ="):
                    J = int(l1.split()[2])
                    break
        if J is None: break
        if maxJ is not None and J > maxJ: break

        rho = []
        offset = None
        kl = None
        Eprev = None
        for l in fp:
            if l.strip() == "": break
            ls = l.split()
            E = int(ls[0])
            if E0 is None: E0 = E
            elif dE is None: dE = E - E0
            elif (Eprev is not None) and (dE != E - Eprev):
                raise ValueError("non-uniform dE")
            
            if dE is not None: offset = int((B2D * J * (J + 1.)) / dE)
            if ((maxE is not None) and (dE is not None) 
                and (E + offset*dE > maxE)):
                Eprev = None
                continue

            Eprev = E
            if nchan is None: nchan = len(ls) - 2
            if kl is None: kl = [[] for ich in range(nchan)]
            rho.append(float(ls[1]))  # 2*J+1 factor is already included in rho
            for ich in range(nchan): kl[ich].append(float(ls[ich+2]))
        
        if (J % dJ) != 0: continue
        if len(rho) == 0: break
        Jl.append(J)
        offsetl.append(offset)
        rhol.append(np.array(rho))
        if kll is None: kll = [[] for ich in range(nchan)]
        for ich in range(nchan): kll[ich].append(np.array(kl[ich]))
        nsiz += len(rho)
    fp.close()
    
    return dE, B2D, Jl, offsetl, rhol, kll


def merge1d(fn, fn_chl):
    """ merge multiple rrkmE files
    fn: output file name
    fn_chl: list of tuples (filename, channel_index) for k(E)  (index starts from 1)
    """
    ofp = open(fn, "w")
    ofp.write("# rho(E) and k(E) from:\n")
    nchan = len(fn_chl)
    fpl = []
    chl = []
    for ich in range(nchan):
        fn, ch = fn_chl[ich]
        fpl.append(open(fn))
        chl.append(ch)
        ofp.write("#   channel %d:  %s, ch.%d\n" % (ich+1, fn, ch))

    ofp.write("# E[cm-1] rho[cm] %s\n" % 
              (" ".join("    k%02d[s-1]" % (ich+1) for ich in range(nchan))))
    El, rhol, kll = None, None, []
    for ich in range(nchan):
        El_this, rhol_this, kl = [], [], []
        for l in fpl[ich]:
            if l.strip() == "": continue
            if l.strip().startswith("#"): continue
            if l.strip().startswith("E"): continue
            ls = l.split()
            El_this.append(int(ls[0]))
            rhol_this.append(float(ls[1]))
            kl.append(float(ls[1+chl[ich]]))
        if El is None:
            El = El_this[:]
            rhol = rhol_this[:]
        elif len(El) != len(El_this):
            raise ValueError("inconsistent nbin: %s, %s" % (len(El), len(El_this)))
        else:
            for i in range(len(El)):
                if El[i] != El_this[i]:
                    raise ValueError("inconsistent E: %s, %s" % (El[i], El_this[i]))
                if (rhol[i] > 1e-16) and (abs(rhol[i]-rhol_this[i])/rhol[i] > 1e-3):
                    raise ValueError("inconsistent rho: %s, %s" % (rhol[i], rhol_this[i]))
        kll.append(kl)
        
    for i in range(len(El)):
        ofp.write(" %6d %12.6e %s\n" % 
                  (El[i], rhol[i], " ".join("%12.6e" % kl[i] for kl in kll)))
    return


def merge2d(fn, fn_chl):
    """ merge multiple rrkmEJ files
    fn: output file name
    fn_chl: list of tuples (filename, channel_index) for k(E,J)  (index starts from 1)
    """
    ofp = open(fn, "w")
    ofp.write("# rho(E,J) and k(E,J) from:\n")
    nchan = len(fn_chl)
    fpl = []
    chl = []
    for ich in range(nchan):
        fn, ch = fn_chl[ich]
        fpl.append(open(fn))
        chl.append(ch)
        ofp.write("#   channel %d:  %s, ch.%d\n" % (ich+1, fn, ch))
    B2Dl = []
    for ich in range(nchan):
        for l in fpl[ich]:
            if l.strip().startswith("#"):
                l1 = l[1:].strip()
                if l1.startswith("B2D ="):
                    B2Dl.append(float(l1.split()[2]))
                    break
    if min(B2Dl) != max(B2Dl): raise ValueError("inconsistent B2D: %s" % (B2Dl))
    ofp.write("# B2D = %g\n" % (B2Dl[0]))
    ofp.write("# E[cm-1] rho[cm] %s\n" % 
              (" ".join("    k%02d[s-1]" % (ich+1) for ich in range(nchan))))

    while True:
        Jl = []
        for ich in range(nchan):
            for l in fpl[ich]:
                if l.strip().startswith("#"):
                    l1 = l[1:].strip()
                    if l1.startswith("J ="):
                        Jl.append(int(l1.split()[2]))
                        break
        if len(Jl) == 0: break
        if min(Jl) != max(Jl): raise ValueError("inconsistent J: %s" % (Jl))
        ofp.write("# J = %d\n" % (Jl[0]))
        El, rhol, kll = None, None, []
        for ich in range(nchan):
            El_this, rhol_this, kl = [], [], []
            for l in fpl[ich]:
                if l.strip() == "": break
                if l.strip().startswith("#"): continue
                if l.strip().startswith("E"): continue
                ls = l.split()
                El_this.append(int(ls[0]))
                rhol_this.append(float(ls[1]))
                kl.append(float(ls[1+chl[ich]]))
            if El is None:
                El = El_this[:]
                rhol = rhol_this[:]
            elif len(El) != len(El_this):
                raise ValueError("inconsistent nbin: %s, %s" % (len(El), len(El_this)))
            else:
                for i in range(len(El)):
                    if El[i] != El_this[i]:
                        raise ValueError("inconsistent E: %s, %s" % (El[i], El_this[i]))
                    if (rhol[i] > 1e-16) and (abs(rhol[i]-rhol_this[i])/rhol[i] > 1e-3):
                        raise ValueError("inconsistent rho: %s, %s" % (rhol[i], rhol_this[i]))
            kll.append(kl)
        if len(El) == 0: break
        for i in range(len(El)):
            ofp.write(" %6d %12.6e %s\n" % 
                      (El[i], rhol[i], " ".join("%12.6e" % kl[i] for kl in kll)))
        ofp.write("\n\n")
    return




